<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
	<title>Pwee - PHP Environment Extender</title>
</head>

<body>

<h1>Pwee - PHP Environment Extender</h1>

<a href="#whatispwee">What is Pwee?</a><br>
<a href="#download">Download</a><br>
<a href="#installation">Installation</a><br>
<a href="#defaultenvironmentconstants">Default Environment Constants</a><br>
<a href="#exportedfunctions">Exported Functions</a><br>
<a href="#xmlenvironmentdefinition">XML Environment Definition</a><br>
<a href="#faq">FAQ</a><br>
<a href="#bugs">Bugs</a><br>
<a href="#todo">TODO</a><br>
<a href="#history">History</a><br>
<a href="#author">Author</a><br>
<a href="#license">License</a><br>
<a href="#samplepackages">Sample Packages</a> (Smarty and ADOdb)<br>

<h1><a name="whatispwee">What is Pwee?</a></h1>

<P>Pwee is a PHP extension that gives web developers the ability to expand the PHP runtime
environment. Developers can use XML to define and add custom constants and variables that
are accessible to each script. The lifetime and scope of constants and variables can be
controlled individually and the scope of variables can be expanded so they are persistent
across multiple requests to the same script executor.</P>

<h2>Example</h2>

<P>An example will help illustrate what kind of problem Pwee solves. If your web application uses
a database, each script needs to know the hostname of the database server (as well as the username
and password). This is easily achieved by hardcoding the hostname in your script.</P>

<PRE>
$db = new Database;
$db->hostname = "foo";
$db->user = "user";
$db->password = "password";
</PRE>

<P>This is very simplistic however. If you have both a development and production network you need to
add logic to the script so your application uses the appropriate database based on where it's running.
One way to achieve this is to base it on the IP address of the server.</P>

<PRE>
$db = new Database;
if (ereg("^192.168.1.", _SERVER["SERVER_ADDR"]))
  $db->hostname = "foo";
else
  $db->hostname = "bar";
</PRE>

<P>This logic fails though if you run your script from the shell because SERVER_ADDR is not defined.
If you run scripts from the shell you have to work up some other way to determine weather you should be using the
production or development database server. The fact remains however that every single time a script
is run it has to examine its environment in order to determine what it should do.</P>

<P>If you want to make the process more efficient an alternative is to create server specific include
files that define the environment without having to examine anything. In this case you would create
two scripts, say production.config.inc and development.config.inc. Each script would
define the constant you can use when connecting to the database.</P>

<I>config.inc links to production.config.inc on production servers:</I>

<PRE>
define(DATABASE_HOSTNAME, "foo");
</PRE>

<I>config.inc links to development.config.inc on development servers:</I>

<PRE>
define(DATABASE_HOSTNAME, "bar");
</PRE>

At the top of each script you just include the configuration script.

<PRE>
require_once("config.inc");

$db = new Database;
$db->hostname = DATABASE_HOSTNAME;
</PRE>

<P>This solution works well but is very error prone because you have to manage two files
that need to have the same name but contain different content. Bad things can happen if
you accidentally overwrite the file on the wrong server. If you have more than two networks it becomes
even more error prone.</P>

<P>Using the Pwee extension you would just create an environment definition in XML.</P>

<PRE>
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;Environments&gt;
  &lt;Application name=&quot;My web application&quot; namespace=&quot;&quot;&gt;
    &lt;Constants&gt;
      &lt;Constant name=&quot;DATABASE_USER&quot; value=&quot;user&quot; /&gt;
      &lt;Constant name=&quot;DATABASE_PASSWORD&quot; value=&quot;password&quot; /&gt;
    &lt;/Constants&gt;
    &lt;Server ip=&quot;192.168.1.&quot;&gt;
      &lt;Constants&gt;
        &lt;Constant name=&quot;DATABASE_HOSTNAME&quot; value=&quot;bar&quot; /&gt;
      &lt;/Constants&gt;
    &lt;/Server&gt;
    &lt;Server ip=&quot;10.10.0.&quot;&gt;
      &lt;Constants&gt;
        &lt;Constant name=&quot;DATABASE_HOSTNAME&quot; value=&quot;foo&quot; /&gt;
      &lt;/Constants&gt;
    &lt;/Server&gt;
  &lt;/Application&gt;
&lt;/Environments&gt;
</PRE>

<P>This environment defines USER and PASSWORD as being server independent whereas HOSTNAME
depends on the IP address of the server. Depending on how you invoke PHP, the environment
definition will only be read once and the appropriate constants will be added to the runtime
environment for all your scripts. The scripts don't need to have any extra logic or waste
any time determining what values for which constants to use.</P>

<p>This example is a good illustration for another problem common to PHP web applications.
Almost every script contains include and require statements. Take the simple script above.</p>

<PRE>
require_once("config.inc");
</PRE>

<p> The question is where exactly is config.inc? If PHP doesn't find this script in the local
directory it's going to search your include path. What if you have multiple projects and each
has it's own config.inc? You could add more path information.</p>

<PRE>
require_once("projectA/config.inc");
</PRE>

<p>But you still might be forcing PHP to search the include path. In order to streamline performance
and keep PHP from searching for the file on every script execution you need to specify the full
path to the file. (Include paths also become an issue if you have a lot of VirtualHosts. You don't want to
include VirtualHost specific directories in the main include_path. If you set the include_path
in .htaccess files you run into trouble when you execute PHP from the shell.)</p>

<PRE>
require_once("/full/path/to/projectA/config.inc");
</PRE>

<p>This works but becomes a nuisance if the full path to your project changes. A common solution
to avoid full paths is to include one main configuration file that defines a constant or variable
that can be used in subsequent include statements.</p>

<PRE>
require_once("projectA/config.inc");
- or -
require_once("/full/path/to/projectA/config.inc");

// config.inc set $INCLUDE_DIR

require_once("$INCLUDE_DIR/classA.php");
require_once("$INCLUDE_DIR/classB.php");
</PRE>

<p>This is a good solution but you are still forced to either search the include path or
have full paths in your scripts. Pwee provides a better solution. You can define a Pwee
environment that defines INCLUDE_DIR as either a variable or as a constant.</p>

<PRE>
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;Environments&gt;
  &lt;Application name=&quot;www.domain.com&quot; namespace=&quot;&quot;&gt;
    &lt;Variables&gt;
      &lt;Variable name=&quot;INCLUDE_DIR&quot; value=&quot;/full/path/to/projectA&quot; /&gt;
    &lt;/Variables&gt;
  &lt;/Application&gt;
&lt;/Environments&gt;
</PRE>

<PRE>
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;Environments&gt;
  &lt;Application name=&quot;www.domain.com&quot; namespace=&quot;&quot;&gt;
    &lt;Constants&gt;
      &lt;Constant name=&quot;INCLUDE_DIR&quot; value=&quot;/full/path/to/projectA/&quot; /&gt;
    &lt;/Constants&gt;
  &lt;/Application&gt;
&lt;/Environments&gt;
</PRE>

<p>Then use that variable or constant as before.</p>

<PRE>
require_once("$INCLUDE_DIR/classA.php");
- or -
require_once(INCLUDE_DIR . "classA.php");
</PRE>

<h1><a name="download">Download</a></h1>

You can download Pwee from <a HREF="http://sourceforge.net/projects/pwee/">SourceForge</a>.

<h1><a name="installation">Installation</a></h1>

<P>Download and extract the Pwee tarball to the PHP extension directory. PHP extensions are
located in the ext subdirectory of the PHP installation. These instructions assume you installed
PHP in /usr/local/src.</P>

<P>NOTE: This version has only been compiled and tested with RedHat Linux. If it works
with anything else, let me know.</P>

<h2>Static Linking</h2>

<p>It makes the most sense to link Pwee directly into PHP to take full advantage of it.</p>

<PRE>
% tar xvfz pwee.tar.gz -C /usr/local/src/php/ext
% cd /usr/local/src/php
% ./buildconf
% ./configure --with-pwee [other options]
</PRE>

<h2>Shared Library</h2>

<PRE>
% tar xvfz pwee.tar.gz -C /usr/local/src/php/ext
% cd /usr/local/src/php
% ./buildconf
% ./configure --with-pwee=shared [other options]
</PRE>

<p>After you install the package and build PHP all that's left is to create an XML environment
definition and add <a href="#phpinisettings">pwee.sysconfpath or pwee.userconfpath</a> settings to your php.ini.</p>

<h2>Virtual Hosts</h2>

<p>If you want to define the environment based on the VirtualHost you can modify your httpd.conf
and add a php_value option for the directory that is the DocumentRoot for the VirtualHost.</p>

<PRE>
&lt;VirtualHost _default_:80&gt;
  ServerName www.domain.com
  DocumentRoot /var/www/www.domain.com
  &lt;Directory /var/www/www.domain.com&gt;
    php_value pwee.userconfpath &quot;/var/www/www.domain.com/pwee.conf.xml&quot;
  &lt;/Directory&gt;
&lt;/VirtualHost&gt;
</PRE>

<p>If you want to define the environment based on a particular directory you can add a php_value
option to a .htaccess file. In order for this to work the AllowOverride property for the
&lt;Directory&gt; that contains the .htaccess must include the value Options or All.</p>

<PRE>
php_value pwee.userconfpath "/var/www/www.domain.com/pwee.conf.xml"
</PRE>

<p>It is more efficient to define the Pwee configuration in the VirtualHost definition in httpd.conf
than using .htaccess. Either one is suitable and Pwee will cache the environment definition internally
for efficiency.</p>

<h2>Requirements</h2>

<P>I have tested Pwee using PHP 4.1.0 and 4.1.2 under RedHat Linux 7.2 using both Apache
and mod_php and Zeus 4.0 and FastCGI. Consider it a blessing if it works with anything else.</P>

<h2><a name="phpinisettings">php.ini Settings</a></h2>

<p>There are a number of different settings that control how Pwee works.</p>

<table width="100%" border="1">
	<TR>
		<TD><B>Name</B></TD>
		<TD><B>Description</B></TD>
	</TR>
	<TR>
		<TD>pwee.sysconfpath</TD>
		<TD>Path to a system wide XML environment definition file. This value can only be set in php.ini.
		There is no default value.</TD>
	</TR>
	<TR>
		<TD>pwee.userconfpath</TD>
		<TD>Path to a user defined XML environment definition file. This value should be set
		on a per directory basis in either httpd.conf or .htaccess. There is no default value.
		Once a user environment is loaded it is cached for efficiency. If you modify the 
		XML definition and want Pwee to reload it you need to append a serial number to the
		end of the path. The serial number is specified following a colon. For example
		conf.xml:1 would specify serial number 1. Any change in this part of the path will
		cause Pwee to reload the definition. Only one userconfpath is active at any given time.
		</TD>
	</TR>
	<TR>
		<TD>pwee.userconf_allow</TD>
		<TD>Determines if Pwee allows user environments to be defined using pwee.userconfpath.
		The default is Yes. This value can only be set in php.ini.</TD>
	</TR>
	<TR>
		<TD>pwee.register_net_constants</TD>
		<TD>Determines if Pwee registers constants for network information such as server IP addresses.
		The default is Yes.</TD>
	</TR>
	<TR>
		<TD>pwee.net_constant_prefix</TD>
		<TD>Prefix to use for network constants. Only applicable when pwee.register_net_constants is Yes.
		The default prefix is 'SERVER'.</TD>
	</TR>
	<TR>
		<TD>pwee.register_uid_constants</TD>
		<TD>Determines if Pwee registers constants that uniquely identify the executor and request.
		The default is Yes.</TD>
	</TR>
	<TR>
		<TD>pwee.exposeinfo</TD>
		<TD>Determines if constants and variables are displayed by phpinfo(). The default is Yes.</TD>
	</TR>
</TABLE>

<h1><a name="defaultenvironmentconstants">Default Environment Constants</a></h1>

<p>Besides the constants and variables defined by XML environment definitions, Pwee defines some
constants itself.</p>

<table width="100%" border="1">
	<TR>
		<TD><B>Name</B></TD>
		<TD><B>Description</B></TD>
	</TR>
	<TR>
		<TD>EXECUTOR_UID</TD>
		<TD>Each script executor is assigned a unique identifier. The identifier is 36 characters
		long and has the format c5e57bc9-d2a4-4521-a29b-ff89382ae878. The lifetime of an executor
		depends on how you invoke PHP. For example, if you are using Apache with mod_php each
		Apache process is an executor.</TD>
	</TR>
	<TR>
		<TD>EXECUTOR_REQUEST_UID</TD>
		<TD>Each script execution (request) is assigned a unique identifier. The identifier is
		41 characters long and has the format 5017d980-f2f1-4b08-a1b8-7e33d161f346-0e33.</TD>
	</TR>
	<TR>
		<TD>SERVER_IFADDR_LO</TD>
		<TD>Defines the IP address of the loopback network device. Almost always 127.0.0.1.</TD>
	</TR>
	<TR>
		<TD>SERVER_IFADDR_ETH[0...]</TD>
		<TD>Defines the IP address of other network devices. One constant will be created
		for each device. There is almost always a SERVER_IFADDR_ETH0 constant.</TD>
	</TR>
	<TR>
		<TD>SERVER_IFADDR</TD>
		<TD>Defines the IP address of the first network device that is not the loopback device.
		Almost always the same as SERVER_IFADDR_ETH0.</TD>
	</TR>
	<TR>
		<TD>SERVER_HOSTNAME</TD>
		<TD>Defines the server hostname. The actual value depends on your server network
		configuration. Under Linux you can see the hostname for your server using the -f option
		to the <i>hostname</i> command.</TD>
	</TR>
	<TR>
		<TD>SERVER_HOSTSHORTNAME</TD>
		<TD>Defines the server short hostname. The actual value depends on your server network
		configuration.  Under Linux you can see the short hostname for your server using the -s option
		to the <i>hostname</i> command.</TD>
	</TR>
	<TR>
		<TD>SERVER_HOSTDOMAIN</TD>
		<TD>Defines the server domain name. The actual value depends on your server network
		configuration.  nder Linux you can see the short hostname for your server using the -d option
		to the <i>hostname</i> command.</TD>
	</TR>
</TABLE>

<h1><a name="exportedfunctions">Exported Functions</a></h1>

<p>Pwee only exports one function right now. The pwee_info() function prints out the same information
as phpinfo() except it only displays Pwee module information.</p>

<h1><a name="xmlenvironmentdefinition">XML Environment Definition</a></h1>

<h2>Document Type Definition</h2>

<PRE>
&lt;!DOCTYPE Environments
[
  &lt;!ELEMENT Environments ((Package|Application)+)&gt;
  &lt;!ELEMENT Application ((Server|Constants|Variables)+)&gt;
    &lt;!ATTLIST Application name CDATA #REQUIRED&gt;
    &lt;!ATTLIST Application namespace CDATA #REQUIRED&gt;
    &lt;!ATTLIST Application comment CDATA #IMPLIED&gt;
  &lt;!ELEMENT Package ((Server|Constants|Variables)+)&gt;
    &lt;!ATTLIST Package name CDATA #REQUIRED&gt;
    &lt;!ATTLIST Package namespace CDATA #REQUIRED&gt;
    &lt;!ATTLIST Package comment CDATA #IMPLIED&gt;
  &lt;!ELEMENT Server ((Constants|Variables)+)&gt;
    &lt;!ATTLIST Server ip CDATA #IMPLIED&gt;
    &lt;!ATTLIST Server interface CDATA #IMPLIED&gt;
    &lt;!ATTLIST Server hostname CDATA #IMPLIED&gt;
    &lt;!ATTLIST Server domain CDATA #IMPLIED&gt;
    &lt;!ATTLIST Server comment CDATA #IMPLIED&gt;
  &lt;!ELEMENT Constants (Constant+)&gt;
    &lt;!ATTLIST Constants prefix CDATA #IMPLIED&gt;
    &lt;!ATTLIST Constants comment CDATA #IMPLIED&gt;
  &lt;!ELEMENT Constant EMPTY&gt;
    &lt;!ATTLIST Constant name CDATA #REQUIRED&gt;
    &lt;!ATTLIST Constant value CDATA #REQUIRED&gt;
    &lt;!ATTLIST Constant type (string|long|boolean|double) &quot;string&quot;&gt;
    &lt;!ATTLIST Constant comment CDATA #IMPLIED&gt;
  &lt;!ELEMENT Variables (Variable+)&gt;
    &lt;!ATTLIST Variables prefix CDATA #IMPLIED&gt;
    &lt;!ATTLIST Variables scope (request|executor) &quot;request&quot;&gt;
    &lt;!ATTLIST Variables comment CDATA #IMPLIED&gt;
  &lt;!ELEMENT Variable EMPTY&gt;
    &lt;!ATTLIST Variable name CDATA #REQUIRED&gt;
    &lt;!ATTLIST Variable value CDATA #REQUIRED&gt;
    &lt;!ATTLIST Variable type (string|long|boolean|double) &quot;string&quot;&gt;
    &lt;!ATTLIST Variable scope (request|executor) #IMPLIED&gt;
    &lt;!ATTLIST Variable comment CDATA #IMPLIED&gt;
]&gt;
</PRE>

<h2>XML Elements</h2>

<h3>Environments</h3>

<p>The Environment element is the document root. It must contain one or more
Application or Package elements.</p>

<h3>Application and Package</h3>

<p>Constants and variables are grouped by Application or Package elements.
Currently there is no difference between these two elements as they have the same
attributes. Application and Package elements must contain one or more Server,
Constants or Variables elements.</p>

<P>
<B>name</B>
- Each Application and Package must be named. This is a string value and is used
for informational purposes only.
</P>

<P>
<B>namespace</B>
- Each Application and Package must define a namespace. The namespace is a string
that will prefix the name of each constant and variable in the Application or Package.
The namespace value will be separated from the constant or variable name with an underscore
character.
</P>

<P>
<B>comment</B>
- The element can have an associated string comment for documentation purposes.
</P>

<h3>Server</h3>

<p>The Server element is used to control the constants and variables that are defined
for particular servers. You can restrict constants and variables based on the server
IP address, hostname or domain. Server elements must contain one or more Constants
and Variables sections. These elements will only apply when the conditions of the Server
element are met.</p>

<P>
<B>ip</B>
- You can restrict the environment defined for a particular server by specifying the
exact IP address of the server. If you want an environment to be applied to multiple servers
you can set the IP address to a particular subnet. For example, if you want to set the
environment for only the server 192.168.1.10 you would set &quot;ip = 192.168.1.10&quot;.
If you have more than one server and want to set the environment for all servers in 
a particular Class C subnet (192.168.1.*) you would set &quot;ip = 192.168.1.&quot; (note
the trailing period).
</P>

<P>
<B>interface</B>
- When defining the environment based on IP address the default is to use the
IP address of the eth0 network interface. If you want to use the IP of a different
network interface you can use this attribute. This attribute is only relative if the
ip attribute is set.
</P>

<P>
<B>hostname</B>
- You can define the environment based on the server hostname instead of the IP address
by setting a value for this attribute instead of the ip attribute. The environment will
only be applied if there is an exact match between this value and the short hostname of the
server. Under Linux you can see the short hostname for your server using the -s option with
the <I>hostname</I> command. If the ip attribute is set the hostname attribute is ignored.
</P>

<P>
<B>domain</B>
- You can define the environment based on the server domain instead of the IP address
by setting a value for this attribute instead of the ip attribute. The environment will
only be applied if there is an exact match between this value and the hostname domain of the
server. Under Linux you can see the hostname domain for your server using the -d option with
the <I>hostname</I> command. If the ip or hostname attribute is set the domain attribute is ignored.
</P>

<P>
<B>comment</B>
- The element can have an associated string comment for documentation purposes.
</P>

<h3>Constants</h3>

<p>Constant elements are grouped together by a Constants element. Constants elements
must contain one or more Constant elements.</p>

<P>
<B>prefix</B>
- Prefix is a string value that will prefix the name of each constant in the element.
The prefix will be separated from the constant name with an underscore character.
This prefix is applied in addition to the namespace prefix for the Application or Package.
</P>

<P>
<B>comment</B>
- The element can have an associated string comment for documentation purposes.
</P>

<h3>Variables</h3>

<p>Variable elements are grouped together by a Variables element. Variables elements
must contain one or more Variable elements</p>

<P>
<B>prefix</B>
- Prefix is a string value that will prefix the name of each variable in the element.
The prefix will be separated from the variable name with an underscore character.
This prefix is applied in addition to the namespace prefix for the Application or Package.
</P>

<P>
<B>scope</B>
- You can apply a scope to a group of Variable elements by setting the scope of the
Variables element. See the description of the Variable scope attribute for a list of
string values that can be used. The default scope is request.
</P>

<P>
<B>comment</B>
- The element can have an associated string comment for documentation purposes.
</P>

<h3>Constant</h3>

<p>Constant elements allow you to define constant values cannot be changed during
script execution.</p>

<P>
<B>name</B>
- Each constant must be named. The actual name of the constant accessible to scripts
depends on the namespace of the Application or Package and whether the Constants element
defined a prefix.
</P>

<P>
<B>value</B>
- The value for the constant. The value must be specified as a string but is
converted to a PHP type based on the type attribute.
</P>

<P>
<B>type</B>
- The constant type can be string, long, boolean or double. If the type is not
specified it is assumed to be a string.
</P>

<P>
<B>comment</B>
- The element can have an associated string comment for documentation purposes.
</P>

<h3>Variable</h3>

<p>Variable elements allow you to define variable values that can be changed during
script execution. Dending on the scope of the variable the lifetime of the
variable can be changed.</p>

<P>
<B>name</B>
- Each variable must be named. The actual name of the variable accessible to scripts
depends on the namespace of the Application or Package and whether the Variables element
defined a prefix.
</P>

<P>
<B>value</B>
- The value for the variable. The value must be specified as a string but is
converted to a PHP type based on the type attribute.
</P>

<P>
<B>type</B>
- The variable type can be string, long, boolean or double. If the type is not
specified it is assumed to be a string.
</P>

<P>
<B>scope</B>
- Scope controls the lifetime of variable. The scope can be request or executor.
If the variable has request scope the value of the variable will be reset for
each request. This is the default scope. The more interesting scope is executor.
This scope allows the variable to retain it's value across multiple requests.
This behavior is greatly dependent on how PHP is invoked. For example,
if you use Apache with mod_php each individual Apache process is considered an
executor. Requests handled by each executor will be able to access and modify the
value available to the next request. Executor scope does not (yet) allow you to define
&quot;application&quot; variables that are shared between all executors.
If you dynamically load the extension as a shared library the executor scope becomes
request scope because the lifetime of the executor and request are the same.
If a Variable scope is set it overrides the scope of the Variables element.
</P>

<P>
<B>comment</B>
- The element can have an associated string comment for documentation purposes.
</P>

<h1><a name="samplepackages">Sample Packages</a></h1>

<h2><a name="smarty">Smarty Template Engine</a></h2>

<P>If you use the <A HREF="http://www.phpinsider.com/php/code/Smarty/">Smarty Template Engine</A>
here is a Pwee package that defines constants that Smarty will use. Smarty uses the
SMARTY_DIR constant to find the location of the Smarty classes. The other constants are useful
only if you change the hardcoded paths in the Smarty class definition.</P>

<PRE>
&lt;Package name=&quot;Smarty&quot; namespace=&quot;SMARTY&quot;&gt;
  &lt;Constants&gt;
    &lt;Constant name=&quot;DIR&quot; value=&quot;/var/www/domain.com/classes/Smarty/&quot; /&gt;
    &lt;Constant name=&quot;TEMPLATE_DIR&quot; value=&quot;/var/www/domain.com/templates/&quot; /&gt;
    &lt;Constant name=&quot;COMPILE_DIR&quot; value=&quot;/var/www/domain.com/cache/Smarty/templates_c/&quot; /&gt;
    &lt;Constant name=&quot;CACHE_DIR&quot; value=&quot;/var/www/domain.com/cache/Smarty/cache/&quot; /&gt;
    &lt;Constant name=&quot;CONFIG_DIR&quot; value=&quot;/var/www/domain.com/classes/Smarty/configs/&quot; /&gt;
  &lt;/Constants&gt;
&lt;/Package&gt;
</PRE>

<h2><a name="adodb">ADOdb Database Library for PHP</a></h2>

<P>If you use the <A HREF="http://php.weblogs.com/ADOdb">ADOdb Database Library for PHP</A> here
is a Pwee package that defines both constants and variables that ADOdb can use. ADOdb uses the
ADODB_DIR constant to find the location of the ADOdb classes. ADOdb will use the ADODB_CACHE_DIR
variable to find the location of the cache directory. If you are using ADOdb for session
management you can define variables the session handler will use. You can include these variables
in a Server block so you can have different connection parameters for production and development
networks.</P>

<PRE>
&lt;Package name=&quot;ADODB&quot; namespace=&quot;ADODB&quot;&gt;
  &lt;Constants&gt;
    &lt;Constant name=&quot;DIR&quot; value=&quot;/var/www/domain.com/classes/adodb&quot; /&gt;
  &lt;/Constants&gt;
  &lt;Variables&gt;
    &lt;Variable name=&quot;CACHE_DIR&quot; value=&quot;/var/www/domain.com/cache/adodb&quot; /&gt;
  &lt;/Variables&gt;
  &lt;Server ip=&quot;192.168.0.&quot; comment=&quot;development servers&quot;&gt;
    &lt;Variables prefix=&quot;SESSION&quot;&gt;
      &lt;Variable name=&quot;DRIVER&quot; value=&quot;mysql&quot; /&gt;
      &lt;Variable name=&quot;USER&quot; value=&quot;user&quot; /&gt;
      &lt;Variable name=&quot;PWD&quot; value=&quot;password&quot; /&gt;
      &lt;Variable name=&quot;DB&quot; value=&quot;database&quot; /&gt;
      &lt;Variable name=&quot;CONNECT&quot; value=&quot;server&quot; /&gt;
      &lt;Variable name=&quot;TBL&quot; value=&quot;sessions&quot; /&gt;
    &lt;/Variables&gt;
  &lt;/Server&gt;
&lt;/Package&gt;
</PRE>

<h1><a name="faq">FAQ</a></h1>

<p>Give it time</p>

<h1><a name="bugs">Bugs</a></h1>

<P>None, of course</P>

<h1><a name="todo">TODO</a></h1>

<P>This list will grow with time but here are a few major things that need to be completed.</P>

<ul type="square">
	<li>The network related functions need to be implemented for Windows</li>
	<li>The UID functions depend on libuuid which is not available for Windows</li>
	<li>I have not tested what happens if a user variable/constant has the same name as a system variable/constant</li>
	<li>User environments should expire so if they are not accessed in some time they are cleared from the cache to conserve memory</li>
	<li>Add variable types for arrays and objects</li>
	<li>Allow constant and variable values to reference or depend on other values</li>
	<li>Read initial values from the database</li>
</ul>

<h1><a name="history">History</a></h1>

<h2>1.0 March 2002</h2>
<P>Initial public release</P>

<h1><a name="author">Author</a></h1>

<P>Lance Lovette (lance_lovette at hotmail.com)</P>

<h1><a name="license">License</a></h1>

<P>Copyright (c) 2002, Lance Lovette<BR>
All rights reserved.</P>

<P>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</P>

<P>The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.</P>

<P>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.</P>

</body>
</html>
